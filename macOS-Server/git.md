# Заметки по использованию Git

[Git](https://git-scm.com/) -  распределённая система управления версиями.
https://github.com/GrigoryKovalev/web-development-notes.git

## Установка на macOS

Сначала устанавливаем [HomeBrew](brew.md), затем с его помощью устанавливаем Git:

	$ brew install git

## Ссылки

1. [Документация](https://git-scm.com/doc).
2. [Pro Git book v1](https://git-scm.com/book/ru/v1). 
3. [Обучающий интерактивный тур](https://githowto.com/ru).

## Использование

### Помощь

По всем командам:

	$ git help

Или помощь по конкретной команде (например, log):

	$ git help log

### Конфигурация

~/.gitconfig - глобальный конфигурационный файл (общий для всех репозиториев) расположен в домашнем каталоге .

.git/config - конфигурационный файл локального репозитория, расположен в каталоге репозитория каждого проекта (например: ~/sites/localhost/.git/config).

#### Добавление пользователя

	$ git config --global user.name "USER"
	$ git config --global user.email USER@MAIL

> USER - имя пользователя.
> USER@MAIL - e-mail.

#### Конфигурация переноса строка для Mac/Linux и Windows

Преобразование переноса строк для Mac/Linux - концы строк из CRLF (\r\n) будут конвертированы в LF (\n) при отправке коммитов:

	$ git config --global core.autocrlf input

Или преобразование переноса строк для Windows - концы строк из LF будут конвертированы в CRLF при выгрузке кода:

	$ git config --global core.autocrlf true

Вывод ошибки в случае обнаружения необратимых преобразований для текущей настройки core.autocrlf:
	
	$ git config --global core.safecrlf true

#### Настройка игнорирования файлов для текущего пользователя

	$ git config --global core.excludesfile ~/.gitexcludes

Далее в папке пользователя нужно создать и отредактировать файл .gitexcludes, добавив файл .DS_Store и другие необходимые файлы, каждый с новой строки:

	$ nano ~/.gitexcludes
	.DS_Store
	.idea/
	#Нажимаем Ctrl + X, подтверждаем сохранение Y и нажимаем Enter.

Устанавливаем редактор "nano" (лучше подходит для простых операций чем vim) по умолчанию для создания и редактирования сообщений коммитов и меток:

	$ git config --global core.editor "nano"

#### Просмотр конфигурации

	$ git config --list
	#or	
	$ git config -l	

### Создание репозитория в каталоге проекта

Переходим в папку проекта и далее все время работаем в ней, например:

	$ cd ~/SITES/SITE

> Знак тильда "~" - сокращенное обозначение домашнего каталога пользователя (например: /Users/USER). 
> SITES - название каталога с проектами (например: ~/sites).
> SITE - название каталога проекта (например: /sites/localhost).

Создаем репозиторий (инициализируем git):

	$ git init

> В каталоге проекта будет создан каталог репозитория .git (например: ~/SITES/SITE/.git)

### Запись изменений в репозиторий

#### Определение состояния файлов

	$ git status 
	
Просмотр только отслеживаемых файлов:

	$ git status --untracked-files=no
	#or
	$ git status -uno

Более подробно просмотр неиндексированных изменений:

	$ git diff	

#### Добавление файлов для отслеживания

Добавление всех файлов для отслеживания в текущем каталоге. (например в: ~/SITES/SITE):
	
	$ git add all
	#or
	$ git add .

Добавление файлов из определенного каталога (например: ~/SITES/SITE/app):

	$ cd app
	$ git add .

Добавление одного файла:

	$ git add index.php
	
#### Фиксация изменений (добавление в репозиторий)

Только индексированных, сразу со своим комментарием:

	$ git commit -m "COMMENT"
	
> COMMENT - комментарий, например: First commit.

Или с ручным добавлением комментария:

	$ git commit

> После этого потребуется ввести свой комментарий или сохранить предложенный.

Также можно использовать расширенные комментарии (в комментариях будет также помещена дельта/diff изменений):

	$ git commit --verbose
	#or
	$ git commit -v

> Настроить по умолчанию выполнение команды git commit с добавлением расширенных комментариев можно установив значение "true" для параметра конфигурации commit.verbose.
	
Если файл отслеживается, но был изменен, необходимо его сначала проиндексировать с помощью команды "git add", либо добавить флаг "-a" для команды "commit":  

	$ git commit -a -m "new"

#### Игнорирование индексации

Создаем и редактируем файл для указания игнорируемых файлов и папок, которые не должны добавляться в репозиторий, например:

	$ nano .gitignore
	/vendor

> Каталог /vendor не будет игнорироваться при добавлении файлов на отслеживание с помощью "git add".

#### Удаление файлов

Удаление файла из отслеживаемых при удалении из каталога (например: test.php):

	$ rm test.php
	$ git rm test.php

Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f.

	$ rm test.php
	$ git rm -f test.php

Удаление файла только из индекса:

	$ git rm --cached test.php

Или группы файлов, например логи ошибок, которые забыли добавить в игнорируемые:

	$ git rm log/\*.log

#### Перемещение файла
	
	$ git mv FILE_FROM FILE_TO
	
> FILE_FROM - текущее место/имя файла, FILE_TO - новое место/имя файла.

### Просмотр истории коммитов

	$ git log

Или с помощью графического интерфейса:

	$ gitk
	
> Решение возможно ошибки при запуске gitk [Error in startup script: unknown color name "lime"](http://stackoverflow.com/questions/34637896/gitk-will-not-start-on-mac-unknown-color-name-lime).

### Отмена изменений

Изменение последнего коммита:

	$ git commit --amend

Например, забыли проиндексировать изменения в файле "git commit -m 'initial commit'":

	$ git add forgotten_file
	$ git commit --amend

Отмена индексации:

	$ git reset HEAD test.php

Отмена изменений в файла после добавления его на отслеживание - безвозвратная:

	$ git add test.php

После изменения в файле добавленном на отслеживание, можно отменить в нем изменения:

	$ git checkout --test.php

### Работа с удаленными репозиториями

Если удаленный репозиторий был клонирован, то он автоматически добавляется с именем "origin" и локальная ветка "master" будет добавлена для отслеживания удаленной ветки "origin/master".

#### Отображение удалённых репозиториев

Просмотр сокращенных названий репозиториев и соответствующих им Url:

	$ git remote -v
	#or только названий
	$ git remote

Инспекция удаленного репозитория:

	$ git remote show ORIGIN

> ORIGIN - сокращенное название удаленного репозитория (например: главного репозитория - origin).

#### Добавление удалённых репозиториев

	$ git remote add ORIGIN GITSERVER:REPOSITORY.git

> ORIGIN - удаленный репозиторий.
> GITSERVER - Git-сервер с удаленным репозиторием, например: GitHub или свой сервер подключаемый по SSH.
> REPOSITORY.git - название удаленного репозитория на Git-сервере (в конце ".git").

#### Fetch и Pull - Получение изменений из удаленного репозитория

**Получение данных из конкретного удаленного репозитория в локальный репозиторий .git, без слияния с текущей локальной веткой (т.е. с данными в каталоге проекта ~/SITES/SITE)**:

	$ git fetch ORIGIN

> ORIGIN - удаленный репозиторий необходимо указывать, если добавлено больше одного репозитория для текущего проекта.

Теперь можно посмотреть какие коммиты сейчас отделяют локальный указатель от указателя, полученного из удалённого репозитория: 

	$ git log MASTER..ORIGIN/MASTER
	#or
	$ git log MASTER ORIGIN/MASTER

> MASTER - локальная ветка.
> ORIGIN/MASTER - УДАЛЕННЫЙ РЕПОЗИТОРИЙ/ВЕТКА НА НЕМ.

Посмотреть расширенную информацию можно с помощью добавления флага "-p", т.е. какие именно изменения произошли и в каких файлах:

	$ git log -p master origin/master

Также можно посмотреть только изменения, без коммитов:

	$ git diff master..origin/master

**После того как мы готовы принять изменения, необходимо выполнить слияние**:

	$ git merge origin/master
	
> Т.е. мы сливаем изменения в удаленном репозитории origin и ветке master, с текущей локальной веткой master.

**Получить данные и сразу слить можно одной командой:**

	$ git pull origin master

Если указать информацию об отслеживаемой ветке (автоматически добавляется при клонировании репозитория), то в дальнейшем можно не указывать удаленный репозиторий и метку установленные по умолчанию:

	$ git branch --set-upstream-to=origin/master master
	$ git pull

#### Push - отправка изменений в удаленный репозиторий

Для репозитория с сокращенным названием origin (определенного по умолчанию при клонировании) и ветки master:

	$ git push origin master

Если указать информацию об отслеживаемой ветке (автоматически добавляется при клонировании репозитория), то в дальнейшем можно не указывать удаленный репозиторий и метку установленные по умолчанию:

	$ git push --set-upstream origin master

То можно отправлять изменения без указания репозитория и ветки, просто:

	$ git push

Просмотреть отслеживаемые метки:

	$ git branch -vv

#### Удаление и переименование удаленных репозиториев

Переименование:

	$ git remote rename REPOSITORY REPOSITORY_NEW

> REPOSITORY - текущее имя репозитория.
> REPOSITORY_NEW - новое имя репозитория.

Удаление:

	$ git remote rm REPOSITORY

Изменение URL:

	$ git remote set-url origin GITSERVER:REPOSITORY.git

### Работа с ветками

Проект стоит сразу разделить на две ветки: master и develop.

Тогда, например, можем вести разработку в ветке develop, ее же выгружаем в удаленный репозиторий в соответствующую ветку develop, на рабочий сервер получаем данные в ветку master из удаленного репозитория из ветки develop.

В необходимости отката изменений, на рабочий сервер получаем данные в ветку master из удаленного репозитория из ветки master.

Когда убеждаем в правильной работе ветки develop, сливаем ее с веткой master в удаленном репозитории.

#### Создание новой ветки

	$ git branch develop

#### Просмотр веток

Посмотреть список имеющихся веток:
	
	$ git branch
	develop
	* master

> Символ *, стоящий перед веткой master, указывает на ветку, на которой вы находитесь в настоящий момент.

Посмотреть последний коммит на каждой из веток:
	
	$ git branch -v

Посмотреть ветки которые слили и не слили:

	$ git branch --merged
	develop
	* master
	$ git branch --no-merged

Посмотреть на какую ветку указывает HEAD:

	$ git log --oneline --decorate
	f11b0d0 (HEAD -> develop, origin/master, master) Update
	4a88b5b Update
	ff01401 Init
	
#### Переключение веток

	$ git checkout develop
	$ git branch
	* develop
	master

Создадим тестовый файл и зафиксируем изменение:

	$ echo "test" > test.rb
	$ git add .
	$ git commit -m 'made a change'
	
Посмотреть куда указывает HEAD:

	$ git log --oneline --decorate
	684ff7a (HEAD -> develop) made a change
	f11b0d0 (origin/master, master) Update
	4a88b5b Update
	ff01401 Init	
	
Переключимся обратно на ветку master:

	$ git checkout master
	
> Эта команда сделала две вещи. Она переместила указатель HEAD назад на ветку "master" и вернула файлы в рабочем каталоге в то состояние, которое было сохранено в снимке (snapshot), на который указывает ветка. Это также означает, что все изменения, вносимые с этого момента, будут отнесены к старой версии проекта. Другими словами, откатилась вся работа, выполненная в ветке "develop".

Сделаем еще несколько изменений и очередной коммит:

	$ > test.rb
	#or
	$ nano test.rb
	$ git add .
	$ git commit -m 'made a change'
	$ echo '1' > test.rb
	$ git commit -a -m 'made other changes'

> Теперь история проекта разделилась. Мы создали ветку, переключились в нее, поработали, а затем вернулись в основную ветку и поработали в ней. Эти изменения изолированы друг от друга: мы можем свободно переключаться туда и обратно, а когда будем готовы — сольем их вместе.
	
Посмотрим историю наших коммитов и увидем, где находятся указатели веток, и как ветвилась история проекта:
	
	$ git log --oneline --decorate --graph --all
	* 0807b43 (HEAD -> master) made other changes
	* 8a9f787 made a change
	| * 684ff7a (develop) made a change
	|/  
	* f11b0d0 (origin/master) Update
	* 4a88b5b Update
	* ff01401 Init

#### Основы ветвления и слияния

Создадим новую ветку и сразу выберем ее:

	$ git checkout -b test
	
Внесем изменения:

	$ > index.html
	$ git add .
	$ git commit -m 'added a new footer [test]'
	
Переключимся обратно на ветку master и выполним слияние с веткой test:

	$ git checkout master
	$ git merge test
	Fast-forward
 	index.html | 0
 	1 file changed, 0 insertions(+), 0 deletions(-)
 	create mode 100644 index.html

> Фразу "fast-forward" (перемотка) означает что коммит, на который указывала ветка, которую мы слили, был прямым потомком того коммита, на котором мы находились, Git просто переместил указатель ветки вперед (так как нет разветвления в работе).

Теперь можно удалить ветку test:

	$ git branch -d test

Перейдем на ветку develop и сольем ее с веткой master:

	$ git checkout develop
	$ git merge master
	КОНФЛИКТ (добавление/добавление): Конфликт слияния в test.rb
	Не удалось провести автоматическое слияние; исправьте конфликты и 	сделайте коммит результата.

> Мы получим сообщение об ошибке, а файл test.rb на ветке develop будет содержать две версии файла, в начале текущую, в конце с ветки master.

Пробуем исправить конфликт, например, сначала переименуем файл test.rb, и сделаем коммит:

	$ mv test.rb test.bak.rb
	$ git commit -m "Rename test.rb"
	
Теперь перейдем на ветку master и выполним слияние с веткой develop:
	
	$ git merge develop
	
Файл test.rb у нас теперь отсутствует вообще в ветке master, копируем файл test.bak.rb в файл test.rb. и оставляем только старое значение (между символами "=======" и ">>>>>>> master"), фиксируем изменения:

	$ cp test.bak.rb test.rb
	$ nano test.rb
	$ git add .
	$ git commit -m "Update after merge"

Переключимся на ветку develop, объединим ее с master, отредактируем test.rb и удалим test.bak.rb, и зафиксируем изменения:

	$ git checkout develop
	$ git merge master
	$ mv test.bak.rb test.rb
	$ nano test.rb
	#сохраним изменения из обоих веток
	test
	1
	$ git add .
	$ git commit -m "Merge test.rb"

Вернемся в ветку merge и объединим ее с веткой develop:

	$ git checkout master
	$ git merge develop

### Настройка своего Git-сервера

#### Клонирование локального репозитория в новый "голый репозиторий"

Входим в каталог проектов:

	$ cd ~/SITES

И клонируем репозиторий проекта с параметром "--bare":

	$ git clone --bare SITE REPOSITORY.git

> SITE - название каталога проекта.
> REPOSITORY.git - название нового "голого репозитория" (например: используем имя проекта SITE и добавляем в конце ".git").

Примерно тоже самое, что мы просто скопируем репозиторий /SITE/.git из каталога проекта в каталог проектов и переименуем его:

	$ cp -Rf ~/SITES/SITE/.git ~/sites/SITE.git

Или клонируем репозиторий внутри каталога проекта:

	$ cd ~/SITES/SITE
	$ git clone --bare .git SITE.git

#### Размещение "голого репозитория" на Git-сервере

	$ scp -r REPOSITORY.git GITSERVER:REPOSITORIES

> REPOSITORIES - путь и название каталога с репозиториями, куда должен быть скопирован "голый репозиторий" (например: ~/repositories).

И можем удалить локальную копию "голого репозитория":

	$ rm REPOSITORY.git

#### Клонирование репозитория c удаленного Git-сервера по SSH

Теперь пользователь, имеющий доступ к Git-серверу, может клонировать удаленный репозиторий по SSH и начать работать над общим проектом.

	$ git clone GITSERVER:REPOSITORY.git

### Настройка своего Git-сервера с помощью Gitolite (предпочтительно)

#### Ссылки

1. [Документация](https://git-scm.com/book/ru/v1/Git-на-сервере-Gitolite).
2. [Официальный сайт](http://gitolite.com/).

#### Установка

Сначала необходимо создать пользователя с именем "git" на Git-сервере (где будет размещен удаленный репозиторий).

Затем настроить вход по SSH на Git-сервер по публичному ключу без возможности входа по паролю.

Скопировать в домашний каталог пользователя ~/git свой публичный ключ id_rsa_USER.pub и переименовать его в USER.pub  (т.е. чтобы в названии было только имя пользователя и расширение .pub):

	$ scp ~/.ssh/id_rsa_USER.pub git@SERVER:~/USER.pub

После чего зайти по SSH на сервер под именем пользователя "git":

	$ ssh git@SERVER

Далее необходимо клонировать репозиторий Gitolite и установить в домашнем каталоге:

	$ git clone git://github.com/sitaramc/gitolite
	$ gitolite/install -ln


Теперь, нужно создать каталог /bin в домашнем каталоге (~/git/bin):

	$ mkdir bin

Добавить $HOME/bin в $PATH:

	$ sudo nano ~/.bash_profile
	#вставляем строку
	export PATH=$PATH:$HOME/bin
	#сохраняем, выходим и выполняем	
	$ source ~/.bash_profile
	
И только после этого выполняем последнюю команду:

	$ gitolite setup -pk $HOME/USER.pub	

> В результате в домашнем каталоге будет создан новый Git-репозиторий с именем /gitolite-admin в каталоге ~/repositories, где в дальнейшем должны размещаться все Git-репозитории.
> А также будет изменен файл ~/.ssh/authorized_keys, в который будет скопирована специальная команда Gitolite и публичный ключ USER.pub.

**И обязательно редактируем /.ssh/authorized_keys, оставляя только ключ Gitolite, иначе при входе на сервер он не будет запускаться:**

	# gitolite start
	...
	# gitolite end

> Теперь вход на сервер по SSH будет закрыт, только те пользователи, чьи публичные ключи добавлены в конфигурацию Gitolite, смогут работать с репозиториями.

Выходим и заново заходим по SSH на сервер под именем пользователя "git", теперь мы не сможем войти на сервер, должно быть выведено сообщение, уведомляющее, что на сервере используется Gitolite, будет показаны доступные для текущего пользователя репозитории и соединение будет закрыто.

#### Настройка

Теперь на локальном компьютере необходимо клонировать репозиторий gitolite-admin  (например, в каталог с проектами ~/sites), с помощью которого будет осуществлять управление доступом к репозиториям на Git-сервере:

	$ cd ~/SITES
	$ git clone git:gitolite-admin

Входим в репозиторий:

	$ cd ~/SITES/gitolite-admin
	#смотрим содержимое каталога
	$ ls
	conf keydir
	#смотрим что в подкаталогах
	$ find conf keydir -type f
	conf/gitolite.conf keydir/grishak.pub
	#смотрим содержимое конфигурационного файла 
	$cat conf/gitolite.conf
	repo gitolite-admin
    	RW+     =   USER
	repo testing
    	RW+     =   @all

> /conf - каталог содержит файл gitolite.conf для настроек уровня доступа к репозиториям.
> /keydir - каталог содержит наш публичный ключ USER.pub, сюда же будет необходимо добавлять публичные ключи других пользователей (т.е. на Git-сервер их добавлять не нужно), например: USER2.pub.

По умолчанию для репозитория gitolite-admin на Git-сервере у пользователя USER доступ на чтение и запись (RW+). Для репозитория testing доступ на чтение и запись у всех пользователей.

 **Теперь для того, чтобы добавить новый репозиторий на Git-сервер, нет необходимости клонировать "голый репозиторий", достаточно добавить в конфигурацию gitolite.conf права на новый репозиторий и затем добавить url на него в локальный репозиторий.**

#### Пример использования

Добавляем права на управление новым репозиторием "test" в gitolite.conf:

	$ nano ~/SITES/gitolite-admin/conf/gitolite.conf
	#и добавляем в конце строчки
	repo test
    	RW+     =   USER

> ~/SITES	- это каталог с проектами в домашнем каталоге (например: ~/Sites).
> test - это название тестового репозитория.
> USER - это имя пользователя, которое используется в названии публичного ключа в ~/SITES/gitolite-admin/keydir/USER.pub.

И отправляем данные в удаленный репозиторий:

	$ cd ~/SITES/gitolite-admin
	$ git commit -a -m "Add new repo test"
	$ git push

> После этого на Git-сервере будет автоматически создан репозиторий "test".

Затем создадим новый локальный проект, перейдем в него и инициализируем Git:

	$ cd ~/SITES
	$ mkdir test
	$ cd test
	$ git init
	
Создадим тестовый файл, добавим его для отслеживания и зафиксируем изменения:

	$ echo "<?php echo 'index';" > index.php
	$ git add .
	$ git commit -m "Init"

Теперь необходимо добавить URL удаленного Git-репозитория:

	$ git remote add origin git:test.git

Далее необходимо отправить изменения из ветки master в новый репозиторий на Git-сервере:

	$ git push origin master
	
Теперь на другом компьютере мы можем клонировать удаленный репозиторий (для примера на локальном компьютере клонируем в другое имя проекта "test2"):

	$ cd ~/SITES
	$ git clone git:test.git test2

Создадим новый файл test.php и добавим его для отслеживания, затем добавим изменение в файл index.php, добавим в индекс все файлы и зафиксируем изменения, отправим их в удаленный репозиторий:

	$ cd test2
	$ echo "<?php echo 'test';" > test.php
	$ git add test.php
	$ echo "echo '+test2';" >> index.php
	$ git commit -a -m "Update"
	$ git push

Вернемся в локальный репозиторий "test", получим новые изменения и сольем их с веткой master:

	$ cd ~/SITES/test
	$ git fetch
	$ git merge origin/master

Либо мы можем одной командой получить и слить новые изменения:

	$ git pull origin master