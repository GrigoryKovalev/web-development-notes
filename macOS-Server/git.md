[toc]

# Заметки по использованию Git

[Git](https://git-scm.com/) -  распределённая система управления версиями.
https://github.com/GrigoryKovalev/web-development-notes.git

<!--ts-->
<!--te-->

## Установка на macOS

Сначала устанавливаем [HomeBrew](brew.md), затем с его помощью устанавливаем Git:

	$ brew install git

## Ссылки

1. [Документация](https://git-scm.com/doc).
2. [Pro Git book v1](https://git-scm.com/book/ru/v1). 
3. [Обучающий интерактивный тур](https://githowto.com/ru).

## Использование

### Вызов помощи

По всем командам:

	$ git help

Или помощь по конкретной команде (например, log):

	$ git help log

### Конфигурация

~/.gitconfig - глобальный конфигурационный файл (общий для всех репозиториев) расположен в домашнем каталоге .

.git/config - конфигурационный файл локального репозитория, расположен в каталоге репозитория каждого проекта (например: ~/sites/localhost/.git/config).

#### Добавление пользователя

	$ git config --global user.name "USER"
	$ git config --global user.email USER@MAIL

> USER - имя пользователя.
> USER@MAIL - e-mail.

#### Конфигурация переноса строк

Преобразование переноса строк для Mac/Linux - концы строк из CRLF (\r\n) будут конвертированы в LF (\n) при отправке коммитов:

	$ git config --global core.autocrlf input

Или преобразование переноса строк для Windows - концы строк из LF будут конвертированы в CRLF при выгрузке кода:

	$ git config --global core.autocrlf true

Вывод ошибки в случае обнаружения необратимых преобразований для текущей настройки core.autocrlf:
	
	$ git config --global core.safecrlf true

#### Настройка игнорирования файлов для текущего пользователя

	$ git config --global core.excludesfile ~/.gitexcludes

Далее в папке пользователя нужно создать и отредактировать файл .gitexcludes, добавив файл .DS_Store и другие необходимые файлы, каждый с новой строки:

	$ nano ~/.gitexcludes
	.DS_Store
	.idea/

#### Текстовый редактор по умолчанию

Устанавливаем редактор "nano" (лучше подходит для простых операций чем vim) по умолчанию для создания и редактирования сообщений коммитов и меток:

	$ git config --global core.editor "nano"

#### Просмотр конфигурации

	$ git config --list
	# или	
	$ git config -l	

### Создание репозитория

Переходим в каталог проекта и далее все время работаем в нем, например:

	$ cd ~/SITES/SITE

> Знак тильда "~" - сокращенное обозначение домашнего каталога пользователя (например, выполнив в терминале "echo $HOME", будет отображен домашний каталог /Users/USER, где USER - имя пользователя). 
> SITES - название каталога с проектами (например: ~/sites).
> SITE - название каталога проекта (например: /sites/localhost).

Создаем репозиторий (инициализируем Git):

	$ git init

> В каталоге проекта будет создан каталог репозитория /.git (например: ~/SITES/SITE/.git)

### Запись изменений в репозиторий

#### Определение состояния файлов

	$ git status

Посмотреть, что изменили, но пока не проиндексировали:

	$ git diff

Сравнить индексированные изменения с последним коммитом:

	$ git diff --cached
	# или
	$ git diff --staged

Более подробно просмотр неиндексированных изменений:

	$ git diff	

#### Добавление файлов для отслеживания

Добавление всех файлов для отслеживания в текущем каталоге. (например: ~/Sites/localhost):
	
	$ git add all
	# или
	$ git add .

Добавление файлов из определенного каталога (например: ~/Sites/localhost/app):

	$ cd app
	$ git add .

Добавление одного файла:

	$ git add index.php
	
#### Фиксация изменений (добавление в репозиторий)

Только индексированных, сразу со своим комментарием:

	$ git commit -m "COMMENT"
	
> COMMENT - комментарий, например: First commit.

Или с использование текстового редактора:

	$ git commit

> После этого потребуется ввести свой комментарий или сохранить предложенный.
	
Если файл отслеживается, но был изменен, необходимо его сначала проиндексировать с помощью команды "git add", либо добавить флаг "-a" для команды "commit":  

	$ git commit -a -m "new"

#### Игнорирование индексации

Создаем в каталоге проекта файл для указания игнорируемых файлов и папок, которые не должны добавляться в репозиторий, и добавляемый игнорируемый каталог, например:

	$ cd ~/Sites/localhost
	$ nano .gitignore
	/vendor

> Каталог /vendor будет игнорироваться при добавлении файлов на отслеживание с помощью "git add".

#### Удаление файлов

Удаление файла из отслеживаемых при удалении из каталога (например:  FILE.php):

	$ rm test.php
	$ git rm test.php
	$ git add .

Если файл изменили и уже проиндексировали, то необходимо использовать принудительное удаление с помощью параметра -f.

	$ rm test.php
	$ git rm -f test.php

Удаление файла только из индекса:

	$ git rm --cached test.php

Или группы файлов, например логи ошибок, которые забыли добавить в игнорируемые:

	$ git rm log/\*.log

#### Перемещение файлов
	
	$ git mv test.php test_new.php
	# или
	$ mv test.php test_new.php
	$ git rm test.php
	$ git add test_new.php
	
> test.php - текущее имя файла, test_new.php - новое имя файла.

### Просмотр истории коммитов

	$ git log

Дополнительный параметр "-p" показывает внесённые изменения, также можно, например, использовать -2, чтобы ограничить вывод до 2-х последних записей:

	$ git log -p -2
	
Получение краткой статистик по каждому коммиту:

	$ git log --stat	

Полезный параметр "--pretty" для изменения формата вывода лога, например, для вывода каждого коммита в одну строку:

	$ git log --pretty=oneline
	
Интересный параметр — это format, который позволяет полностью создать собственный формат вывода лога:

	$ git log --pretty=format:"%h - %an, %ar : %s"

> [Список наиболее полезных параметров формата](https://git-scm.com/book/ru/v1/Основы-Git-Просмотр-истории-коммитов) (Таблица 2-1).

Параметр добавляющий ASCII-граф, показывающий историю ветвлений и слияний:

	$ git log --pretty=format:"%h %s" --graph

Графический интерфейс:

	$ gitk

### Отмена изменений

Изменение последнего коммита:

	$ git commit --amend

Например, если после совершения коммита вспомнили, что забыли проиндексировать изменения в файле, которые хотели добавить в этот коммит:

	$ git commit -m 'initial commit'
	$ git add FILE.txt
	$ git commit --amend

Отмена индексации файла:

	$ git reset HEAD FILE.txt

Подсказка по команде отображается после выполнения команды индексации и просмотра статуса:

	$ git add .
	$ git status
	# ...
	# (используйте «git reset HEAD <файл>…», чтобы убрать из индекса)
	# ...

Отмена изменений (безвозвратная) в файле после добавления его на отслеживание:

	$ git checkout -- index.php

Подсказка по команде отображается после внесения изменения в отслеживаемый файл и просмотра статуса:

	$ git status
	# ...
	# (используйте «git checkout -- <файл>…», чтобы отменить изменения
	# ...	

### Работа с удаленными репозиториями

Если удаленный репозиторий был клонирован, то он автоматически добавляется с именем "origin" и локальная ветка "master" будет добавлена для отслеживания удаленной ветки "origin/master".

#### Отображение удалённых репозиториев

Посмотреть сокращенные названия репозиториев:

	$ git remote
	# илиigin git:test.git

Просмотр сокращенных названий репозиториев и соответствующих им Url:

	$ git remote -v
	# илиigin https://github.com/user/test.git (fetch)
	# илиigin https://github.com/user/test.git (push)

Инспекция удаленного репозитория:

	$ git remote show origin

> origin - сокращенное название удаленного репозитория.

#### Добавление удалённых репозиториев

Добавляем удаленный репозиторий origin:

	$ git remote add origin https://github.com/user/test.git

> test.git - название удаленного репозитория на Git-сервере (в конце ".git").

#### Fetch и Pull - Получение изменений из удаленного репозитория

**Получаем изменения из удаленного репозитория:***

	$ git fetch origin
	
> Данные будут скопированы в локальный репозиторий в каталоге проекта (например: ~/Sites/localhost/.git), но не будут слиты с текущей веткой (например: master), т.е. данные в каталоге проекта не будут изменены.

**Теперь можно посмотреть изменения**, т.е. какие именно коммиты сейчас отделяют локальный указатель от указателя, полученного из удалённого репозитория: 

	$ git log master..origin/master
	# или
	$ git log master..origin/master

> master - текущая локальная ветка.
> origin/master - удаленный репозиторий/ветка.

Посмотреть расширенную информацию можно с помощью добавления флага "-p", т.е. какие именно изменения произошли и в каких файлах:

	$ git log -p master origin/master

Или можно посмотреть только изменения, без коммитов:

	$ git diff master..origin/master

**Когда мы готовы принять изменения, необходимо выполнить слияние**:

	$ git merge origin/master
	
> Т.е. мы сливаем изменения в удаленном репозитории origin и ветке master, с текущей локальной веткой master (при условии что выбрана эта метка или мы не создавали других меток).

**Получить изменения и сразу выполнить слияние можно одной командой:**

	$ git pull origin master

>  Полученные изменения из удаленного репозитория origin и ветки master, будут слиты с текущей локальной веткой master.

Можно установить информацию об отслеживаемой ветке в удаленном репозитории (автоматически добавляется при клонировании репозитория):

	$ git branch --set-upstream-to=origin/master master

Просмотреть отслеживаемые метки:

	$ git branch -vv	
	
Тогда при получения изменений, можно не указывать удаленный репозиторий и ветку: 

	$ git pull

#### Push - отправка изменений в удаленный репозиторий

	$ git push origin master

> Отправка изменений в удаленный репозиторий origin и ветку master.

Можно установить внешнюю ветку как вышестоящую для этой ветки (автоматически добавляется при клонировании репозитория), тоже самое, что установить информацию об отслеживаемой ветке:

	 $ git push --set-upstream origin master

Тогда при отправке изменений, можно не указывать удаленный репозиторий и ветку: 

	$ git push

#### Удаление и переименование удаленных репозиториев

Переименование:

	$ git remote rename origin origin_new

Удаление:

	$ git remote rm origin

Изменение URL:

	$ git remote set-url origin https://github.com/user/test2.git

### Работа с ветками

Проект стоит сразу разделить на две ветки: master и develop.

Тогда, например, можем вести разработку в ветке develop, ее же выгружаем в удаленный репозиторий в соответствующую ветку develop, на рабочий сервер получаем данные в ветку master из удаленного репозитория из ветки develop.

В необходимости отката изменений, на рабочий сервер получаем данные в ветку master из удаленного репозитория из ветки master.

Когда убеждаем в правильной работе ветки develop, сливаем ее с веткой master в удаленном репозитории.

#### Создание новой ветки

	$ git branch develop

#### Просмотр веток

Посмотреть список имеющихся веток:
	
	$ git branch
	develop
	* master

> Символ *, стоящий перед веткой master, указывает на ветку, на которой вы находитесь в настоящий момент.

Посмотреть последний коммит на каждой из веток:
	
	$ git branch -v

Посмотреть ветки которые слили и не слили:

	$ git branch --merged
	develop
	* master
	$ git branch --no-merged

Посмотреть на какую ветку указывает HEAD:

	$ git log --oneline --decorate
	f11b0d0 (HEAD -> develop, origin/master, master) Update
	4a88b5b Update
	ff01401 Init
	
#### Переключение веток

	$ git checkout develop
	$ git branch
	* develop
	master

Создадим тестовый файл и зафиксируем изменение:

	$ echo "test" > test.rb
	$ git add .
	$ git commit -m 'made a change'
	
Посмотреть куда указывает HEAD:

	$ git log --oneline --decorate
	684ff7a (HEAD -> develop) made a change
	f11b0d0 (origin/master, master) Update
	4a88b5b Update
	ff01401 Init	
	
Переключимся обратно на ветку master:

	$ git checkout master
	
> Эта команда сделала две вещи. Она переместила указатель HEAD назад на ветку "master" и вернула файлы в рабочем каталоге в то состояние, которое было сохранено в снимке (snapshot), на который указывает ветка. Это также означает, что все изменения, вносимые с этого момента, будут отнесены к старой версии проекта. Другими словами, откатилась вся работа, выполненная в ветке "develop".

Сделаем еще несколько изменений и очередной коммит:

	$ > test.rb
	# или
	$ nano test.rb
	$ git add .
	$ git commit -m 'made a change'
	$ echo '1' > test.rb
	$ git commit -a -m 'made other changes'

> Теперь история проекта разделилась. Мы создали ветку, переключились в нее, поработали, а затем вернулись в основную ветку и поработали в ней. Эти изменения изолированы друг от друга: мы можем свободно переключаться туда и обратно, а когда будем готовы — сольем их вместе.
	
Посмотрим историю наших коммитов и увидем, где находятся указатели веток, и как ветвилась история проекта:
	
	$ git log --oneline --decorate --graph --all
	* 0807b43 (HEAD -> master) made other changes
	* 8a9f787 made a change
	| * 684ff7a (develop) made a change
	|/  
	* f11b0d0 (origin/master) Update
	* 4a88b5b Update
	* ff01401 Init

#### Основы ветвления и слияния

Создадим новую ветку и сразу выберем ее:

	$ git checkout -b test
	
Внесем изменения:

	$ > index.html
	$ git add .
	$ git commit -m 'added a new footer [test]'
	
Переключимся обратно на ветку master и выполним слияние с веткой test:

	$ git checkout master
	$ git merge test
	Fast-forward
 	index.html | 0
 	1 file changed, 0 insertions(+), 0 deletions(-)
 	create mode 100644 index.html

> Фразу "fast-forward" (перемотка) означает что коммит, на который указывала ветка, которую мы слили, был прямым потомком того коммита, на котором мы находились, Git просто переместил указатель ветки вперед (так как нет разветвления в работе).

Теперь можно удалить ветку test:

	$ git branch -d test

Перейдем на ветку develop и сольем ее с веткой master:

	$ git checkout develop
	$ git merge master
	КОНФЛИКТ (добавление/добавление): Конфликт слияния в test.rb
	Не удалось провести автоматическое слияние; исправьте конфликты и 	сделайте коммит результата.

> Мы получим сообщение об ошибке, а файл test.rb на ветке develop будет содержать две версии файла, в начале текущую, в конце с ветки master.

Пробуем исправить конфликт, например, сначала переименуем файл test.rb, и сделаем коммит:

	$ mv test.rb test.bak.rb
	$ git commit -m "Rename test.rb"
	
Теперь перейдем на ветку master и выполним слияние с веткой develop:
	
	$ git merge develop
	
Файл test.rb у нас теперь отсутствует вообще в ветке master, копируем файл test.bak.rb в файл test.rb. и оставляем только старое значение (между символами "=======" и ">>>>>>> master"), фиксируем изменения:

	$ cp test.bak.rb test.rb
	$ nano test.rb
	$ git add .
	$ git commit -m "Update after merge"

Переключимся на ветку develop, объединим ее с master, отредактируем test.rb и удалим test.bak.rb, и зафиксируем изменения:

	$ git checkout develop
	$ git merge master
	$ mv test.bak.rb test.rb
	$ nano test.rb
	#сохраним изменения из обоих веток
	test
	1
	$ git add .
	$ git commit -m "Merge test.rb"

Вернемся в ветку merge и объединим ее с веткой develop:

	$ git checkout master
	$ git merge develop

### Настройка своего Git-сервера

#### Клонирование локального репозитория в новый "голый репозиторий"

Входим в каталог проектов, например:

	$ cd ~/Sites

И клонируем репозиторий проекта с параметром "--bare":

	$ git clone --bare SITE REPOSITORY.git

> SITE - название каталога проекта (например: localhost).
> REPOSITORY.git - название нового "голого репозитория" (например: используем имя проекта localhost и добавляем в конце ".git").

Примерно тоже самое, что мы просто скопируем репозиторий ~/SITE/.git из каталога проекта в каталог проектов и переименуем его:

	$ cp -Rf ~/Sites/localhost/.git ~/repositories/localhost.git

#### Размещение "голого репозитория" на Git-сервере

	$ scp -r localhost.git GIT@SERVER:REPOSITORY.git

> GIT@SERVER - удаленный Git-сервер;
> REPOSITORY.git - удаленный репозиторий (например: localhost).

И можем удалить локальную копию "голого репозитория":

	$ rm localhost.git

#### Клонирование репозитория c удаленного Git-сервера

Теперь пользователь, имеющий доступ к Git-серверу по SSH, может клонировать удаленный репозиторий и начать работать над общим проектом.

	$ cd ~/Sites
	$ git clone GIT@SERVER:localhost.git

### Настройка своего Git-сервера с помощью Gitolite (предпочтительно)

#### Ссылки

1. [Документация](https://git-scm.com/book/ru/v1/Git-на-сервере-Gitolite).
2. [Официальный сайт](http://gitolite.com/).

#### Установка

Сначала необходимо создать пользователя с именем "git" на Git-сервере (где будет размещен удаленный репозиторий).

Затем настроить вход по SSH на Git-сервер по публичному ключу без возможности входа по паролю.

Скопировать в домашний каталог пользователя ~/git свой публичный ключ id_rsa_USER.pub и переименовать его в USER.pub (т.е. чтобы в названии было только имя пользователя и расширение .pub):

	$ scp ~/.ssh/id_rsa_USER.pub git@SERVER:~/USER.pub

После чего зайти по SSH на сервер под именем пользователя "git":

	$ ssh git@SERVER

Далее необходимо клонировать репозиторий Gitolite и установить в домашнем каталоге:

	$ git clone git://github.com/sitaramc/gitolite
	$ gitolite/install -ln

Теперь, нужно создать каталог /bin в домашнем каталоге (~/git/bin):

	$ mkdir bin
	
Добавить $HOME/bin в $PATH:

	$ sudo nano ~/.bash_profile
	#вставляем строку
	export PATH=$PATH:$HOME/bin
	#сохраняем, выходим и выполняем	
	$ source ~/.bash_profile
	
И только после этого выполняем последнюю команду:

	$ gitolite setup -pk $HOME/USER.pub	

> В результате в домашнем каталоге будет создан новый Git-репозиторий с именем /gitolite-admin в каталоге ~/repositories, где в дальнейшем должны размещаться все Git-репозитории.
> А также будет изменен файл ~/.ssh/authorized_keys, в который будет скопирована специальная команда Gitolite и публичный ключ USER.pub.

**И обязательно редактируем /.ssh/authorized_keys, оставляя только ключ Gitolite, иначе при входе на сервер он не будет запускаться:**

	# gitolite start
	...
	# gitolite end

> Теперь вход на сервер по SSH будет закрыт, только те пользователи, чьи публичные ключи добавлены в конфигурацию Gitolite, смогут работать с репозиториями.

Выходим и заново заходим по SSH на сервер под именем пользователя "git", теперь мы не сможем войти на сервер, должно быть выведено сообщение, уведомляющее, что на сервере используется Gitolite, будет показаны доступные для текущего пользователя репозитории и соединение будет закрыто:

	$ ssh git@SERVER
	hello USER, this is git@SERVER running gitolite3
	R W	 gitolite-admin
	R W	 testing

#### Настройка

Теперь на локальном компьютере необходимо клонировать репозиторий gitolite-admin  (например, в каталог с проектами ~/sites), с помощью которого будет осуществляться управление доступом к репозиториям на Git-сервере:

	$ cd ~/SITES
	$ git clone git:gitolite-admin

Входим в репозиторий:

	$ cd ~/SITES/gitolite-admin
	$ ls
	# conf keydir
	$ find conf keydir -type f
	# conf/gitolite.conf keydir/grishak.pub
	$ cat conf/gitolite.conf
	# repo gitolite-admin
	# 	RW+     =   USER
	# repo testing
	# 	RW+     =   @all

> /conf - каталог содержит файл gitolite.conf для настроек уровня доступа к репозиториям.
> /keydir - каталог содержит наш публичный ключ USER.pub, сюда же будет необходимо добавлять публичные ключи других пользователей (т.е. на Git-сервер их добавлять не нужно), например: USER2.pub.

По умолчанию для репозитория gitolite-admin на Git-сервере у пользователя USER доступ на чтение и запись (RW+). Для репозитория testing доступ на чтение и запись у всех пользователей (@all).

 **Теперь для того, чтобы добавить новый репозиторий на Git-сервер, нет необходимости клонировать "голый репозиторий", достаточно добавить в конфигурацию gitolite.conf права на новый репозиторий и затем добавить url на него в локальный репозиторий.**

#### Пример использования

Добавляем права на управление новым репозиторием "test" в gitolite.conf:

	$ nano ~/SITES/gitolite-admin/conf/gitolite.conf
	# и добавляем в конце строчки
	repo test
    	RW+     =   USER

> ~/SITES	- это каталог с проектами в домашнем каталоге (например: ~/Sites).
> test - это название тестового репозитория.
> USER - это имя пользователя, которое используется в названии публичного ключа в ~/Sites/gitolite-admin/keydir/USER.pub.

И отправляем данные в удаленный репозиторий:

	$ cd ~/Sites/gitolite-admin
	$ git commit -a -m "Add new repo test"
	$ git push

> После этого на Git-сервере будет автоматически создан репозиторий "test".

Затем создадим новый локальный проект, перейдем в него и инициализируем Git:

	$ cd ~/Sites
	$ mkdir test
	$ cd test
	$ git init
	
Создадим тестовый файл, добавим его для отслеживания и зафиксируем изменения:

	$ echo "index" > index.md
	$ git add .
	$ git commit -m "Init"

Теперь необходимо добавить URL удаленного Git-репозитория:

	$ git remote add origin git:test.git

Далее необходимо отправить изменения в новый репозиторий на Git-сервере:

	$ git push origin master
	
Теперь на другом компьютере мы можем клонировать удаленный репозиторий (для примера на локальном компьютере клонируем в другое имя проекта "test2"):

	$ cd ~/Sites
	$ git clone git:test.git test2

Создадим новый файл test.md и добавим его для отслеживания, затем добавим изменение в файл index.md, добавим в индекс все файлы и зафиксируем изменения, отправим их в удаленный репозиторий:

	$ cd test2
	$ echo "test" > test.md
	$ git add test.php
	$ echo "test2" >> index.md
	$ git commit -a -m "Update"
	$ git push

Вернемся в локальный репозиторий "test", получим новые изменения и сольем их с веткой master:

	$ cd ~/Sites/test
	$ git pull origin master
